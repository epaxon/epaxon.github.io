
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Rate-coding with Integrate-and-Fire neurons &#8212; Neuromorphic Algorithms Research</title>
    
  <link href="../_static/css/theme.css" rel="stylesheet">
  <link href="../_static/css/index.ff1ffe594081f20da1ef19478df9384b.css" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-book-theme.css?digest=c3fdc42140077d1ad13ad2f1588a4309" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="../_static/js/index.be7d3bbb2ef33a8344ce.js">

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/togglebutton.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../_static/sphinx-book-theme.d59cb220de22ca1c485ebbdc042f0030.js"></script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script async="async" src="https://unpkg.com/thebe@0.5.1/lib/index.js"></script>
    <script>
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Connecting IFR theory to connectionism" href="connecting_if_neurons.html" />
    <link rel="prev" title="Computational Neuroscience" href="computational_neuroscience.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="../_static/neural_circuit.png" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">Neuromorphic Algorithms Research</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        <ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../index.html">
   Neuromorphic Algorithms Research
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  About me
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../about_me.html">
   E. Paxon Frady
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Research
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../Research/spiking_networks.html">
   Spiking Neural Networks
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/>
  <label for="toctree-checkbox-1">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../Research/tpam_demo.html">
     Threshold Phasor Associative Memory
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../Research/theoretical_neuroscience.html">
   Theoretical Neuroscience
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/>
  <label for="toctree-checkbox-2">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../Research/sparse_binding_demo.html">
     Sparse binding demo – What’s the dollar of mexico?
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../Research/resonator_networks.html">
   Resonator Networks
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/>
  <label for="toctree-checkbox-3">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../Research/resonator_template.html">
     Factorization of shape, color and location
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../Research/res_semi_primes-220216.html">
     Factoring semi-primes with the resonator network
    </a>
   </li>
  </ul>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Tutorials
 </span>
</p>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1 current active has-children">
  <a class="reference internal" href="computational_neuroscience.html">
   Computational Neuroscience
  </a>
  <input checked="" class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" type="checkbox"/>
  <label for="toctree-checkbox-4">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul class="current">
   <li class="toctree-l2 current active">
    <a class="current reference internal" href="#">
     Rate-coding with Integrate-and-Fire neurons
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="connecting_if_neurons.html">
     Connecting IFR theory to connectionism
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="hodgkin_huxley_paradigm.html">
     The Hodgkin Huxley Paradigm
    </a>
   </li>
  </ul>
 </li>
</ul>

    </div>
</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
                data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
                aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
                title="Toggle navigation" data-toggle="tooltip" data-placement="left">
                <i class="fas fa-bars"></i>
                <i class="fas fa-arrow-left"></i>
                <i class="fas fa-arrow-up"></i>
            </button>
            
            
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="../_sources/Tutorials/spiking_basics_brian2.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.ipynb</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
                onclick="printPdf(this)" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

            <!-- Source interaction buttons -->

            <!-- Full screen (wrap in <a> to have style consistency -->

<a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
        data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
        title="Fullscreen mode"><i
            class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Launch interactive content"><i class="fas fa-rocket"></i></button>
    <div class="dropdown-buttons">
        
        <a class="binder-button" href="https://mybinder.org/v2/gh/executablebooks/jupyter-book/master?urlpath=tree/Tutorials/spiking_basics_brian2.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Launch Binder" data-toggle="tooltip"
                data-placement="left"><img class="binder-button-logo"
                    src="../_static/images/logo_binder.svg"
                    alt="Interact on binder">Binder</button></a>
        
        
        
        
    </div>
</div>

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show noprint">
            
            <div class="tocsection onthispage pt-5 pb-3">
                <i class="fas fa-list"></i> Contents
            </div>
            <nav id="bd-toc-nav" aria-label="Page">
                <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#simulating-if-neurons">
   Simulating IF neurons
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#i-f-neuron-theory">
   I&amp;F neuron theory
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#derivation-of-instantaneous-firing-rate-ifr">
     Derivation of instantaneous-firing-rate (IFR)
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#linear-approximation-to-ifr">
     Linear approximation to IFR
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#spike-threshold">
     Spike threshold
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#if-neuron-with-refractory-period">
   IF neuron with refractory period
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#ifr-theory-with-refractory-period">
     IFR theory with refractory period
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#conclusions">
   Conclusions
  </a>
 </li>
</ul>

            </nav>
        </div>
    </div>
</div>
    <!-- Table of contents that is only displayed when printing the page -->
    <div id="jb-print-docs-body" class="onlyprint">
        <h1>Rate-coding with Integrate-and-Fire neurons</h1>
        <!-- Table of contents -->
        <div id="print-main-content" class="row">
            <div class="col-12 col-md-12 pl-md-5 pr-md-5">
            <div id="jb-print-toc">
                
                <div>
                    <h2> Contents </h2>
                </div>
                <nav aria-label="Page">
                    <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#simulating-if-neurons">
   Simulating IF neurons
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#i-f-neuron-theory">
   I&amp;F neuron theory
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#derivation-of-instantaneous-firing-rate-ifr">
     Derivation of instantaneous-firing-rate (IFR)
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#linear-approximation-to-ifr">
     Linear approximation to IFR
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#spike-threshold">
     Spike threshold
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#if-neuron-with-refractory-period">
   IF neuron with refractory period
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#ifr-theory-with-refractory-period">
     IFR theory with refractory period
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#conclusions">
   Conclusions
  </a>
 </li>
</ul>

                </nav>
            </div>
            
              <div>
                
  <div class="tex2jax_ignore mathjax_ignore section" id="rate-coding-with-integrate-and-fire-neurons">
<h1>Rate-coding with Integrate-and-Fire neurons<a class="headerlink" href="#rate-coding-with-integrate-and-fire-neurons" title="Permalink to this headline">¶</a></h1>
<p>Here, we will go over the basic spiking neuron model, the integrate-and-fire neuron. We will be using the <a class="reference external" href="https://briansimulator.org/">Brian2</a> simulator for designing the networks and experiments.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pylab</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">brian2</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">time</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="k">matplotlib</span> inline

<span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;font.size&#39;</span><span class="p">:</span> <span class="mi">18</span><span class="p">})</span>
<span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;font.family&#39;</span><span class="p">:</span> <span class="s1">&#39;serif&#39;</span><span class="p">,</span> 
                     <span class="s1">&#39;font.serif&#39;</span><span class="p">:[</span><span class="s1">&#39;Computer Modern&#39;</span><span class="p">]})</span>
</pre></div>
</div>
</div>
</div>
<p>One aspect of Brian2 that I really appreciate is its use of physical units. It is generally useful to remember the units and it helps better understand the physical relationships to the dynamical equations in the simulation. Sometimes this type of thing can be frustrating when programming, but the unit checking engine actually helps to prevent mistakes and can make debugging easier.</p>
<p>To that end, we are modeling neurons using the classic integrate-and-fire neuron model. When we model biological neurons, we actually use the abstraction of electronic circuits, which means that our simulation uses Maxwell’s equations. Thus, we will also use physical units of electricity and values that are close to appropriate for biology.</p>
<p>The essential equation for the simplified integrate-and-fire neuron is based on an RC circuit in electronics:</p>
<div class="math notranslate nohighlight">
\[
C\frac{dV}{dt} = g_l (E_l - V) + I
\]</div>
<p>In this equation, <span class="math notranslate nohighlight">\(C\)</span> (Capacitance), <span class="math notranslate nohighlight">\(E_l\)</span> (Resting potential), and <span class="math notranslate nohighlight">\(g_l\)</span> leak conductance, are parameters of the neuron. The state variable <span class="math notranslate nohighlight">\(V\)</span> represents the voltage, and the variable <span class="math notranslate nohighlight">\(I\)</span> is the input, which is taken as a current.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Define the constants and equations for the neuron model</span>

<span class="c1"># Neuron parameters</span>
<span class="n">C_Ax</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">nF</span> <span class="c1"># Capacitance </span>
<span class="n">g_l</span> <span class="o">=</span>  <span class="mf">5.0</span> <span class="o">*</span> <span class="n">nS</span> <span class="c1"># leak conductance</span>

<span class="n">E_l</span> <span class="o">=</span> <span class="o">-</span><span class="mf">60.0</span> <span class="o">*</span> <span class="n">mV</span> <span class="c1"># Resting potential</span>
<span class="n">V_t</span> <span class="o">=</span> <span class="o">-</span><span class="mf">55.0</span> <span class="o">*</span> <span class="n">mV</span> <span class="c1"># Threshold</span>
<span class="n">V_r</span> <span class="o">=</span> <span class="o">-</span><span class="mf">60.0</span> <span class="o">*</span> <span class="n">mV</span> <span class="c1"># Reset</span>

<span class="n">tref</span><span class="o">=</span><span class="mi">0</span><span class="o">*</span><span class="n">ms</span> <span class="c1"># refractory period</span>

<span class="n">eqs_if</span> <span class="o">=</span> <span class="n">Equations</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;</span>
<span class="s1">    dV/dt = (g_l * (E_l - V) + I_ext + I_syn) / C_Ax : volt (unless refractory)</span>
<span class="s1">    I_ext : amp</span>
<span class="s1">    I_syn : amp</span>
<span class="s1">    &#39;&#39;&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="simulating-if-neurons">
<h2>Simulating IF neurons<a class="headerlink" href="#simulating-if-neurons" title="Permalink to this headline">¶</a></h2>
<p>The integrate-and-fire neuron is just this capacitor equation with a spiking mechanism. In the most basic models, the spiking mechanism is simply a threshold. When the voltage exceeds this threshold, then the model outputs a “spike” and then the voltage is reset to a reset potential. The IF model does not actually simulate the spike dynamics. A refractory period is also often used, which forces the neuron to be inactive for a short period after a spike, but first we will start with the refractory period as 0.</p>
<p>Now, we are going to simulate the neuron model and examine the firing rate for a steady current injection. To do so, we will generate a group of IF neurons and inject each of them with different amounts of current. We will then count the number of output spikes to find a relationship between current and number of spikes.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Make a group of IF neurons</span>
<span class="n">N_s</span> <span class="o">=</span> <span class="mi">50</span>
<span class="n">G_post</span> <span class="o">=</span> <span class="n">NeuronGroup</span><span class="p">(</span><span class="n">N_s</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="n">eqs_if</span><span class="p">,</span> 
                     <span class="n">threshold</span><span class="o">=</span><span class="s1">&#39;V&gt;V_t&#39;</span><span class="p">,</span> 
                     <span class="n">reset</span><span class="o">=</span><span class="s1">&#39;V=V_r&#39;</span><span class="p">,</span> 
                     <span class="n">refractory</span><span class="o">=</span><span class="n">tref</span><span class="p">)</span>

<span class="c1"># Set initial conditions and inputs</span>
<span class="n">G_post</span><span class="o">.</span><span class="n">V</span> <span class="o">=</span> <span class="n">E_l</span> <span class="o">*</span> <span class="n">ones</span><span class="p">(</span><span class="n">N_s</span><span class="p">)</span>
<span class="c1"># Give each neuron a different amount of input current</span>
<span class="n">G_post</span><span class="o">.</span><span class="n">I_ext</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="n">N_s</span><span class="p">)</span> <span class="o">*</span> <span class="n">nA</span>

<span class="c1"># Monitor the simulation</span>
<span class="n">SpM_post</span> <span class="o">=</span> <span class="n">SpikeMonitor</span><span class="p">(</span><span class="n">G_post</span><span class="p">)</span>
<span class="n">StM_post</span> <span class="o">=</span> <span class="n">StateMonitor</span><span class="p">(</span><span class="n">G_post</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">record</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># Build the simulation network</span>
<span class="n">ifr_net</span> <span class="o">=</span> <span class="n">Network</span><span class="p">()</span>
<span class="n">ifr_net</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">G_post</span><span class="p">)</span>
<span class="n">ifr_net</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">SpM_post</span><span class="p">)</span>
<span class="n">ifr_net</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">StM_post</span><span class="p">)</span>

<span class="n">ifr_net</span><span class="o">.</span><span class="n">store</span><span class="p">(</span><span class="s1">&#39;init&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">run_time</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">second</span>
<span class="n">ifr_net</span><span class="o">.</span><span class="n">restore</span><span class="p">(</span><span class="s1">&#39;init&#39;</span><span class="p">)</span>
<span class="n">tst</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="n">ifr_net</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">run_time</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;elapsed&quot;</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">tst</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>WARNING    Removing unsupported flag &#39;-march=native&#39; from compiler flags. [brian2.codegen.cpp_prefs]
INFO       No numerical integration method specified for group &#39;neurongroup&#39;, using method &#39;exact&#39; (took 0.15s). [brian2.stateupdaters.base.method_choice]
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>elapsed 6.414305925369263
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">post_spikes</span> <span class="o">=</span> <span class="n">SpM_post</span><span class="o">.</span><span class="n">spike_trains</span><span class="p">()</span>
<span class="n">tot_spikes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N_s</span><span class="p">)</span>
<span class="n">ifr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N_s</span><span class="p">)</span>

<span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mf">3.5</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">post_spikes</span><span class="p">)):</span>
    <span class="n">plot</span><span class="p">(</span><span class="n">post_spikes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">second</span><span class="p">,</span> <span class="n">i</span> <span class="o">*</span> <span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">post_spikes</span><span class="p">[</span><span class="n">i</span><span class="p">])),</span> <span class="s1">&#39;|k&#39;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">post_spikes</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># estimate based on total spikes during simulation</span>
        <span class="n">tot_spikes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">post_spikes</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="c1"># estimate based on time between spikes</span>
        <span class="n">ifr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">post_spikes</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
    
<span class="n">ylim</span><span class="p">([</span><span class="mi">0</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">N_s</span><span class="o">-</span><span class="mf">0.5</span><span class="p">])</span>
<span class="n">xlim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">run_time</span><span class="o">/</span><span class="n">second</span><span class="p">])</span>
<span class="n">yticks</span><span class="p">([])</span>
<span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Time (s)&#39;</span><span class="p">)</span>
<span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Neuron&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Text(0, 0.5, &#39;Neuron&#39;)
</pre></div>
</div>
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>findfont: Font family [&#39;serif&#39;] not found. Falling back to DejaVu Sans.
findfont: Generic family &#39;serif&#39; not found because none of the following families were found: Computer Modern
</pre></div>
</div>
<img alt="../_images/spiking_basics_brian2_8_2.png" src="../_images/spiking_basics_brian2_8_2.png" />
</div>
</div>
<p>Lets take a look at the voltage dynamics of a particular neuron.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plot_idx</span> <span class="o">=</span> <span class="mi">15</span>

<span class="n">plot</span><span class="p">(</span><span class="n">StM_post</span><span class="o">.</span><span class="n">t</span><span class="p">,</span> <span class="n">StM_post</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">plot_idx</span><span class="p">])</span>
<span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Time (s)&#39;</span><span class="p">)</span>
<span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Voltage (V)&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Text(0, 0.5, &#39;Voltage (V)&#39;)
</pre></div>
</div>
<img alt="../_images/spiking_basics_brian2_10_1.png" src="../_images/spiking_basics_brian2_10_1.png" />
</div>
</div>
<p>This is a pretty simple dynamical system, and we can basically see how the simple RC circuit model is integrating the input current. Once the voltage reaches the threshold, then a spike is triggered and the voltage is instantly reset to the reset potential.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mf">3.5</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>

<span class="n">Id</span> <span class="o">=</span> <span class="n">G_post</span><span class="o">.</span><span class="n">I_ext</span>

<span class="n">plot</span><span class="p">(</span><span class="n">Id</span> <span class="o">/</span> <span class="n">nA</span><span class="p">,</span> <span class="n">tot_spikes</span> <span class="o">/</span> <span class="n">run_time</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Input Current (nA)&#39;</span><span class="p">)</span>
<span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Firing Rate (Hz)&#39;</span><span class="p">)</span>
<span class="n">xlim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">Id</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">nA</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(0.0, 0.2)
</pre></div>
</div>
<img alt="../_images/spiking_basics_brian2_12_1.png" src="../_images/spiking_basics_brian2_12_1.png" />
</div>
</div>
<p>We plotted the number of spikes during the 1-second simulation period. There seems to be a pretty simple pattern, but the result is a bit jagged. This is simply because there are some artifacts due to the way we calculated spikes per second. Basically the limited amount of simulation time leads to some rounding errors in our calculation.</p>
<p>As an alternative, lets estimate spikes per second based on the time between spikes for each neuron.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mf">3.5</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>

<span class="n">Id</span> <span class="o">=</span> <span class="n">G_post</span><span class="o">.</span><span class="n">I_ext</span>

<span class="n">plot</span><span class="p">(</span><span class="n">Id</span> <span class="o">/</span> <span class="n">nA</span><span class="p">,</span> <span class="n">ifr</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Input Current (nA)&#39;</span><span class="p">)</span>
<span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Firing Rate (Hz)&#39;</span><span class="p">)</span>
<span class="n">xlim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">Id</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">nA</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(0.0, 0.2)
</pre></div>
</div>
<img alt="../_images/spiking_basics_brian2_14_1.png" src="../_images/spiking_basics_brian2_14_1.png" />
</div>
</div>
<p>Now we can see clearly that the firing rate as a function of input current has some clear properties. There is a threshold below which there are no spikes.
When we have large amounts of current, then it seems that there is a linear relationship between current and firing rate.
We can solve some calculus problems to theoretically understand these properties.</p>
</div>
<div class="section" id="i-f-neuron-theory">
<h2>I&amp;F neuron theory<a class="headerlink" href="#i-f-neuron-theory" title="Permalink to this headline">¶</a></h2>
<p>We see from the simulations that the integrate-and-fire neuron model has a nearly linear input-output function – i.e. the number of spikes per second or the spiking rate appears to be linear with respect to input current once above the threshold. If we examine the model carefully, we can see that there is a basic calculus problem we can solve that will help us theoretically understand the behavior of the neuron.</p>
<div class="section" id="derivation-of-instantaneous-firing-rate-ifr">
<h3>Derivation of instantaneous-firing-rate (IFR)<a class="headerlink" href="#derivation-of-instantaneous-firing-rate-ifr" title="Permalink to this headline">¶</a></h3>
<p>To understand the relationship between firing rate and input current, we want to compute the time it takes to reach the threshold potential when starting at the reset potential when given a constant current input, <span class="math notranslate nohighlight">\(I_s\)</span>. Lets start with the differential equation for the IF neuron:</p>
<div class="math notranslate nohighlight">
\[
C \frac{dV}{dt} = g_l (E_l - V) + I_s
\]</div>
<p>This is a simple enough differential equation that we can actually solve it.</p>
<p>First, separate the Voltage and Time terms:</p>
<div class="math notranslate nohighlight">
\[
C\frac{dV}{g_l (E_l - V) + I_s} = dt
\]</div>
<p>Integrate both sides:</p>
<div class="math notranslate nohighlight">
\[
\int C\frac{dV}{g_l (E_l - V) + I_s} = \int dt
\]</div>
<div class="math notranslate nohighlight">
\[
- \frac{C}{g_l} \log (g_l (E_l - V) + I_s) = t + K
\]</div>
<p>Solve for V:</p>
<div class="math notranslate nohighlight">
\[
g_l (E_l - V) + I_s = K e^{-\frac{g_l}{C} t}
\]</div>
<div class="math notranslate nohighlight">
\[
V = I_s/g_l + E_l - K e^{-\frac{g_l}{C} t}
\]</div>
<p>(Note that above we have the constant <span class="math notranslate nohighlight">\(K\)</span> absorb the exponential function and the division by g_l.)</p>
<p>We want to solve for the time it takes to reach threshold starting from the reset potential. Therefore, we will set an initial condition where <span class="math notranslate nohighlight">\(V(t=0) = V_r\)</span>. We solve for the constant K based on this initial condition.</p>
<div class="math notranslate nohighlight">
\[
V_r = I_s/g_l + E_l - K
\]</div>
<div class="math notranslate nohighlight">
\[
K = g_l(E_l-V_r)+I_s
\]</div>
<p>With this initial condition giving us the integration constant, we can next solve the equation for the time <span class="math notranslate nohighlight">\(T_{spike}\)</span> at which the voltage exceeds the threshold <span class="math notranslate nohighlight">\(V(t=T_{spike}) = V_t\)</span>.</p>
<div class="math notranslate nohighlight">
\[
V_t = I_s/g_l + E_l - K e^{-\frac{g_l}{C} T_{spike}}
\]</div>
<div class="math notranslate nohighlight">
\[
\log \Big( \frac{g_l (E_l - V_t) + I_s}{g_l (E_l - V_r) + I_s} \Big) = \log e^{-\frac{g_l}{C} T_{spike}}
\]</div>
<p>Giving:</p>
<div class="math notranslate nohighlight">
\[
T_{spike} = \frac{C}{g_l} \log \Big( \frac{I_s + g_l (E_l - V_r)}{I_s + g_l (E_l - V_t)} \Big)
\]</div>
<p>The <em>instantaneous-firing-rate</em> (<span class="math notranslate nohighlight">\(IFR\)</span>) is the inverse of <span class="math notranslate nohighlight">\(T_{spike}\)</span>:</p>
<div class="math notranslate nohighlight">
\[
IFR = 1 / T_{spike}
\]</div>
</div>
<div class="section" id="linear-approximation-to-ifr">
<h3>Linear approximation to IFR<a class="headerlink" href="#linear-approximation-to-ifr" title="Permalink to this headline">¶</a></h3>
<p>Nice! We now have an equation for the spiking rate given a constant input current. What a fun little calculus problem.</p>
<p>We see that the plot appears to converge to a straight line, but our equation for the <span class="math notranslate nohighlight">\(IFR\)</span> looks far from linear. How can we mathematically derive this line?</p>
<p>If we want a linear apporximation of firing rate, then we need a linear formulation:</p>
<div class="math notranslate nohighlight">
\[
\tilde{IFR} = m I_s + b
\]</div>
<p>To find the line, then note that the linear relationship we see in the plots only becomes linear for large values of the input current. With this, we can use a limit to compute the slope of the line:</p>
<div class="math notranslate nohighlight">
\[
m = \lim_{I_s \to \infty} \frac{d}{dI_s} IFR
\]</div>
<p>I’ll leave it to you to work out the calculus, this one gets pretty gnarly… Alternatively, we can just use <a class="reference external" href="https://www.wolframalpha.com/input/?i2d=true&amp;i=Limit%5BD%5BDivide%5B1%2CDivide%5BC%2Cg%5Dlog%5C%2840%29Divide%5B%5C%2840%29I%2Bg*%5C%2840%29E_l-V_r%5C%2841%29%5C%2841%29%2C%5C%2840%29I%2Bg*%5C%2840%29E_l-V_t%5C%2841%29%5C%2841%29%5D%5C%2841%29%5D%2CI%5D%2CI-%3Einfinity%5D">wolframalpha</a>!</p>
<p>This gives us a pretty simple formula for the slope of the line:</p>
<div class="math notranslate nohighlight">
\[
m = \frac{1.0}{C (V_{t} - V_{r})}
\]</div>
<p>With this as the slope, we can then solve for <span class="math notranslate nohighlight">\(b\)</span> based on:</p>
<div class="math notranslate nohighlight">
\[
b = \lim_{I_s \to \infty} IFR - m I_s 
\]</div>
<p>Yes, <a class="reference external" href="https://www.wolframalpha.com/input/?i2d=true&amp;i=Limit%5BDivide%5B1%2C%5C%2840%29Divide%5BC%2Cg%5D%5C%2841%29+*log%5C%2840%29Divide%5B%5C%2840%29I%2Bg*%5C%2840%29P-R%5C%2841%29%5C%2841%29%2C%5C%2840%29I%2Bg*%5C%2840%29P-T%5C%2841%29%5C%2841%29%5D%5C%2841%29%5D-Divide%5BI%2CC*%5C%2840%29T-R%5C%2841%29%5D%2CI-%3Einfinity%5D">wolframalpha</a> time!
Leaving us with an equation for the offset:</p>
<div class="math notranslate nohighlight">
\[
b = \frac{-g_l ((V_{t} - E_l) + (V_{r} - E_l))}{2C_{Ax} (V_{t} - V_{r})}
\]</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">m_ifr</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">C_Ax</span> <span class="o">*</span> <span class="p">(</span><span class="n">V_t</span> <span class="o">-</span> <span class="n">V_r</span><span class="p">))</span>
<span class="n">b</span> <span class="o">=</span> <span class="o">-</span><span class="n">g_l</span> <span class="o">*</span> <span class="p">(</span><span class="n">V_t</span> <span class="o">+</span> <span class="n">V_r</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">E_l</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">C_Ax</span> <span class="o">*</span> <span class="p">(</span><span class="n">V_t</span> <span class="o">-</span> <span class="n">V_r</span><span class="p">))</span>


<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;slope:&quot;</span><span class="p">,</span> <span class="n">m_ifr</span><span class="p">,</span> 
      <span class="s2">&quot;; offset:&quot;</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>slope: 1.e+11 s^-1 A^-1 ; offset: -1.25 Hz
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="spike-threshold">
<h3>Spike threshold<a class="headerlink" href="#spike-threshold" title="Permalink to this headline">¶</a></h3>
<p>There is one other useful property that we can derive from the mathematics of the IF neuron, the minimum threshold for spiking.</p>
<p>If we look at the formula for <span class="math notranslate nohighlight">\(T_{spike}\)</span>, we can see that if the input current <span class="math notranslate nohighlight">\(I_s\)</span> is small, then the term inside of the logarithm is negative. When this is the case, then there will be no output spikes. As soon as the current makes the term inside the logarithm positive, then the neuron will produce spikes. So it is very simple to find the minimum current <span class="math notranslate nohighlight">\(I_{min}\)</span> needed to produce any output spikes:</p>
<div class="math notranslate nohighlight">
\[
I_{min} + g_l (E_l - V_t) &gt; 0
\]</div>
<div class="math notranslate nohighlight">
\[
I_{min} &gt; g_l (V_t - E_l)
\]</div>
<p>This makes intuitive sense, there must be enough current to reach the threshold potential and overcome the leakage.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">I_min</span> <span class="o">=</span> <span class="n">g_l</span> <span class="o">*</span> <span class="p">(</span><span class="n">V_t</span> <span class="o">-</span> <span class="n">E_l</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">I_min</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>25. pA
</pre></div>
</div>
</div>
</div>
<p>Finally, lets see how the theory fits with the simulation.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mf">3.5</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>

<span class="n">Id</span> <span class="o">=</span> <span class="n">G_post</span><span class="o">.</span><span class="n">I_ext</span>

<span class="n">plot</span><span class="p">(</span><span class="n">Id</span> <span class="o">/</span> <span class="n">nA</span><span class="p">,</span> <span class="n">ifr</span> <span class="o">/</span> <span class="n">second</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<span class="n">t_spike</span> <span class="o">=</span> <span class="n">C_Ax</span> <span class="o">/</span> <span class="n">g_l</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">((</span><span class="n">Id</span><span class="o">+</span><span class="n">g_l</span><span class="o">*</span><span class="p">(</span><span class="n">E_l</span> <span class="o">-</span> <span class="n">V_r</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="n">Id</span><span class="o">+</span><span class="n">g_l</span><span class="o">*</span><span class="p">(</span><span class="n">E_l</span> <span class="o">-</span> <span class="n">V_t</span><span class="p">)))</span>
<span class="n">fr</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">t_spike</span>
<span class="n">fr</span><span class="p">[</span><span class="n">isnan</span><span class="p">(</span><span class="n">fr</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>

<span class="n">plot</span><span class="p">(</span><span class="n">Id</span><span class="o">/</span><span class="n">nA</span><span class="p">,</span> <span class="n">fr</span> <span class="o">/</span> <span class="n">second</span><span class="p">,</span> <span class="s1">&#39;--r&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>


<span class="c1">#Ish = np.linspace(0, G_post.I_ext[-1]/nA, 500) * nA</span>

<span class="n">plot</span><span class="p">(</span><span class="n">Id</span><span class="o">/</span><span class="n">nA</span><span class="p">,</span> <span class="p">(</span><span class="n">m_ifr</span> <span class="o">*</span> <span class="n">Id</span> <span class="o">+</span> <span class="n">b</span><span class="p">),</span> <span class="s1">&#39;:c&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<span class="n">plot</span><span class="p">([</span><span class="n">I_min</span><span class="p">,</span> <span class="n">I_min</span><span class="p">]</span><span class="o">/</span><span class="n">nA</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">15</span><span class="p">],</span> <span class="s1">&#39;:m&#39;</span><span class="p">)</span>


<span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Input Current (nA)&#39;</span><span class="p">)</span>
<span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Firing Rate (Hz)&#39;</span><span class="p">)</span>
<span class="n">xlim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">Id</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">nA</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>WARNING    /opt/homebrew/Caskroom/miniforge/base/lib/python3.9/site-packages/brian2/units/fundamentalunits.py:208: RuntimeWarning: divide by zero encountered in log
  return func(np.array(x, copy=False), *args, **kwds)
 [py.warnings]
WARNING    /opt/homebrew/Caskroom/miniforge/base/lib/python3.9/site-packages/brian2/units/fundamentalunits.py:208: RuntimeWarning: invalid value encountered in log
  return func(np.array(x, copy=False), *args, **kwds)
 [py.warnings]
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(0.0, 0.2)
</pre></div>
</div>
<img alt="../_images/spiking_basics_brian2_22_2.png" src="../_images/spiking_basics_brian2_22_2.png" />
</div>
</div>
</div>
</div>
<div class="section" id="if-neuron-with-refractory-period">
<h2>IF neuron with refractory period<a class="headerlink" href="#if-neuron-with-refractory-period" title="Permalink to this headline">¶</a></h2>
<p>One final thing we can examine is the refractory period. The refractory period has long been observed in neuroscience, where after spiking the neuron is unresponsive to inputs. This is typically due to the dynamics of the channels during a biophysical spike. When using integrate-and-fire neurons, the refractory period is simply a period where the dynamics of the neuron are clamped to the reset potential. Its very simple to add a refractory period to a neuron in Brian2.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">tref</span> <span class="o">=</span> <span class="mi">50</span><span class="o">*</span><span class="n">ms</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Make a group of IF neurons</span>
<span class="n">N_s</span> <span class="o">=</span> <span class="mi">50</span>
<span class="n">G_post</span> <span class="o">=</span> <span class="n">NeuronGroup</span><span class="p">(</span><span class="n">N_s</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="n">eqs_if</span><span class="p">,</span> 
                     <span class="n">threshold</span><span class="o">=</span><span class="s1">&#39;V&gt;V_t&#39;</span><span class="p">,</span> 
                     <span class="n">reset</span><span class="o">=</span><span class="s1">&#39;V=V_r&#39;</span><span class="p">,</span> 
                     <span class="n">refractory</span><span class="o">=</span><span class="n">tref</span><span class="p">)</span>

<span class="c1"># Set initial conditions and inputs</span>
<span class="n">G_post</span><span class="o">.</span><span class="n">V</span> <span class="o">=</span> <span class="n">E_l</span> <span class="o">*</span> <span class="n">ones</span><span class="p">(</span><span class="n">N_s</span><span class="p">)</span>
<span class="n">G_post</span><span class="o">.</span><span class="n">I_ext</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">N_s</span><span class="p">)</span> <span class="o">*</span> <span class="n">nA</span>

<span class="c1"># Monitor the simulation</span>
<span class="n">SpM_post</span> <span class="o">=</span> <span class="n">SpikeMonitor</span><span class="p">(</span><span class="n">G_post</span><span class="p">)</span>
<span class="n">StM_post</span> <span class="o">=</span> <span class="n">StateMonitor</span><span class="p">(</span><span class="n">G_post</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">record</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># Build the simulation network</span>
<span class="n">ifr_net</span> <span class="o">=</span> <span class="n">Network</span><span class="p">()</span>
<span class="n">ifr_net</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">G_post</span><span class="p">)</span>
<span class="n">ifr_net</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">SpM_post</span><span class="p">)</span>
<span class="n">ifr_net</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">StM_post</span><span class="p">)</span>

<span class="n">ifr_net</span><span class="o">.</span><span class="n">store</span><span class="p">(</span><span class="s1">&#39;init&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">run_time</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">second</span>
<span class="n">ifr_net</span><span class="o">.</span><span class="n">restore</span><span class="p">(</span><span class="s1">&#39;init&#39;</span><span class="p">)</span>
<span class="n">tst</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="n">ifr_net</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">run_time</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;elapsed&quot;</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">tst</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>INFO       No numerical integration method specified for group &#39;neurongroup_1&#39;, using method &#39;exact&#39; (took 0.05s). [brian2.stateupdaters.base.method_choice]
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>elapsed 5.269563913345337
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">post_spikes</span> <span class="o">=</span> <span class="n">SpM_post</span><span class="o">.</span><span class="n">spike_trains</span><span class="p">()</span>
<span class="n">tot_spikes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N_s</span><span class="p">)</span>
<span class="n">ifr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N_s</span><span class="p">)</span>

<span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mf">3.5</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">post_spikes</span><span class="p">)):</span>
    <span class="n">plot</span><span class="p">(</span><span class="n">post_spikes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">second</span><span class="p">,</span> <span class="n">i</span> <span class="o">*</span> <span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">post_spikes</span><span class="p">[</span><span class="n">i</span><span class="p">])),</span> <span class="s1">&#39;|k&#39;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">post_spikes</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># estimate based on total spikes during simulation</span>
        <span class="n">tot_spikes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">post_spikes</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="c1"># estimate based on time between spikes</span>
        <span class="n">ifr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">post_spikes</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
    
<span class="n">ylim</span><span class="p">([</span><span class="mi">0</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">N_s</span><span class="o">-</span><span class="mf">0.5</span><span class="p">])</span>
<span class="n">xlim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">run_time</span><span class="o">/</span><span class="n">second</span><span class="p">])</span>
<span class="n">yticks</span><span class="p">([])</span>
<span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Time (s)&#39;</span><span class="p">)</span>
<span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Neuron&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Text(0, 0.5, &#39;Neuron&#39;)
</pre></div>
</div>
<img alt="../_images/spiking_basics_brian2_27_1.png" src="../_images/spiking_basics_brian2_27_1.png" />
</div>
</div>
<div class="section" id="ifr-theory-with-refractory-period">
<h3>IFR theory with refractory period<a class="headerlink" href="#ifr-theory-with-refractory-period" title="Permalink to this headline">¶</a></h3>
<p>Including the refractory period <span class="math notranslate nohighlight">\(\tau_{ref}\)</span> is quite simple in our theoretical analysis. We just add the refractory period to the formula for <span class="math notranslate nohighlight">\(T_{spike}\)</span>:</p>
<div class="math notranslate nohighlight">
\[
T_{spike} = \frac{C}{g_l} \log \Big( \frac{I_s + g_l (E_l - V_r)}{I_s + g_l (E_l - V_t)} \Big) + \tau_{ref}
\]</div>
<p>However, it should be obvious that this new formula will not continue to converge to a straight line. Rather, the refractory period causes the spiking rate to saturate to a maximum. This maximum spike rate is simply:</p>
<div class="math notranslate nohighlight">
\[
IFR_{max} = 1/\tau_{ref}
\]</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ifr_max</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">tref</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mf">3.5</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>

<span class="n">Id</span> <span class="o">=</span> <span class="n">G_post</span><span class="o">.</span><span class="n">I_ext</span>

<span class="n">plot</span><span class="p">(</span><span class="n">Id</span> <span class="o">/</span> <span class="n">nA</span><span class="p">,</span> <span class="n">ifr</span> <span class="o">/</span> <span class="n">second</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<span class="n">t_spike</span> <span class="o">=</span> <span class="n">C_Ax</span> <span class="o">/</span> <span class="n">g_l</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">((</span><span class="n">Id</span><span class="o">+</span><span class="n">g_l</span><span class="o">*</span><span class="p">(</span><span class="n">E_l</span> <span class="o">-</span> <span class="n">V_r</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="n">Id</span><span class="o">+</span><span class="n">g_l</span><span class="o">*</span><span class="p">(</span><span class="n">E_l</span> <span class="o">-</span> <span class="n">V_t</span><span class="p">)))</span> <span class="o">+</span> <span class="n">tref</span>
<span class="n">fr</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">t_spike</span>
<span class="n">fr</span><span class="p">[</span><span class="n">isnan</span><span class="p">(</span><span class="n">fr</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>

<span class="n">plot</span><span class="p">(</span><span class="n">Id</span><span class="o">/</span><span class="n">nA</span><span class="p">,</span> <span class="n">fr</span> <span class="o">/</span> <span class="n">second</span><span class="p">,</span> <span class="s1">&#39;--r&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>


<span class="c1">#Ish = np.linspace(0, G_post.I_ext[-1]/nA, 500) * nA</span>

<span class="n">plot</span><span class="p">(</span><span class="n">Id</span><span class="o">/</span><span class="n">nA</span><span class="p">,</span> <span class="p">(</span><span class="n">m_ifr</span> <span class="o">*</span> <span class="n">Id</span> <span class="o">+</span> <span class="n">b</span><span class="p">),</span> <span class="s1">&#39;:c&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<span class="n">plot</span><span class="p">([</span><span class="n">I_min</span><span class="p">,</span> <span class="n">I_min</span><span class="p">]</span><span class="o">/</span><span class="n">nA</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">15</span><span class="p">],</span> <span class="s1">&#39;:m&#39;</span><span class="p">)</span>

<span class="n">plot</span><span class="p">([</span><span class="n">Id</span><span class="p">[:]</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">Id</span><span class="p">[:]</span><span class="o">.</span><span class="n">max</span><span class="p">()]</span><span class="o">/</span><span class="n">nA</span><span class="p">,</span> <span class="p">[</span><span class="n">ifr_max</span><span class="p">,</span> <span class="n">ifr_max</span><span class="p">],</span> <span class="s1">&#39;:b&#39;</span><span class="p">)</span>


<span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Input Current (nA)&#39;</span><span class="p">)</span>
<span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Firing Rate (Hz)&#39;</span><span class="p">)</span>
<span class="n">xlim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">Id</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">nA</span><span class="p">])</span>
<span class="n">ylim</span><span class="p">([</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">30</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>WARNING    /opt/homebrew/Caskroom/miniforge/base/lib/python3.9/site-packages/brian2/units/fundamentalunits.py:208: RuntimeWarning: divide by zero encountered in log
  return func(np.array(x, copy=False), *args, **kwds)
 [py.warnings]
WARNING    /opt/homebrew/Caskroom/miniforge/base/lib/python3.9/site-packages/brian2/units/fundamentalunits.py:208: RuntimeWarning: invalid value encountered in log
  return func(np.array(x, copy=False), *args, **kwds)
 [py.warnings]
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(-5.0, 30.0)
</pre></div>
</div>
<img alt="../_images/spiking_basics_brian2_30_2.png" src="../_images/spiking_basics_brian2_30_2.png" />
</div>
</div>
</div>
</div>
<div class="section" id="conclusions">
<h2>Conclusions<a class="headerlink" href="#conclusions" title="Permalink to this headline">¶</a></h2>
<p>We covered here how we can formalize the integrate-and-fire neuron into a reliable mathematical model where information is represented by the firing rate of the spikes. We were able to derive an equation, the <span class="math notranslate nohighlight">\(IFR\)</span>, that computes the firing rate based on the input current and the parameters of the neuron model. We also showed that this function is rectified linear when there is no refractory period, and that it is saturating when there is a refractory period, and we analyzed useful approximations to have a mathematical grasp on the behavior of IF neurons.</p>
<p>The analysis done here required the assumption that the inputs to the neurons are static. But is this useful then when the inputs are changing as data comes in from sensors? This is a type of approximation that is often used in control theory, where we can define a regime in which the equations are valid based on dynamics that are occuring at different time-scales. In this case, we are assuming that the input changes slowly compared to the spiking output. Effectively, for the <span class="math notranslate nohighlight">\(IFR\)</span> equations to be useful, we assume that the input is band-limited and lower frequency than the typical spiking frequency. We can be sure of such situations based on the timeconstants of the neurons and synapses.</p>
<p>But, what if the inputs are fast compared to the neurons? Well, in this case we must rely on a different theory – this regime is outside the scope of the <span class="math notranslate nohighlight">\(IFR\)</span> theory.</p>
<p>To fully connect the dynamics of integrate-and-fire neurons to connectionist theory, we must also exmaine how spikes interact with synapses and how these are integrated to perform computations like the dot-product. In the next section, we will explore exactly how IF models can be used to compute the dot-product and fully tie-in basic spiking models into connectionist theory.</p>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./Tutorials"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
            </div>
        </div>
    </div>
    <div id="main-content" class="row noprint">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="tex2jax_ignore mathjax_ignore section" id="rate-coding-with-integrate-and-fire-neurons">
<h1>Rate-coding with Integrate-and-Fire neurons<a class="headerlink" href="#rate-coding-with-integrate-and-fire-neurons" title="Permalink to this headline">¶</a></h1>
<p>Here, we will go over the basic spiking neuron model, the integrate-and-fire neuron. We will be using the <a class="reference external" href="https://briansimulator.org/">Brian2</a> simulator for designing the networks and experiments.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pylab</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">brian2</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">time</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="k">matplotlib</span> inline

<span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;font.size&#39;</span><span class="p">:</span> <span class="mi">18</span><span class="p">})</span>
<span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;font.family&#39;</span><span class="p">:</span> <span class="s1">&#39;serif&#39;</span><span class="p">,</span> 
                     <span class="s1">&#39;font.serif&#39;</span><span class="p">:[</span><span class="s1">&#39;Computer Modern&#39;</span><span class="p">]})</span>
</pre></div>
</div>
</div>
</div>
<p>One aspect of Brian2 that I really appreciate is its use of physical units. It is generally useful to remember the units and it helps better understand the physical relationships to the dynamical equations in the simulation. Sometimes this type of thing can be frustrating when programming, but the unit checking engine actually helps to prevent mistakes and can make debugging easier.</p>
<p>To that end, we are modeling neurons using the classic integrate-and-fire neuron model. When we model biological neurons, we actually use the abstraction of electronic circuits, which means that our simulation uses Maxwell’s equations. Thus, we will also use physical units of electricity and values that are close to appropriate for biology.</p>
<p>The essential equation for the simplified integrate-and-fire neuron is based on an RC circuit in electronics:</p>
<div class="math notranslate nohighlight">
\[
C\frac{dV}{dt} = g_l (E_l - V) + I
\]</div>
<p>In this equation, <span class="math notranslate nohighlight">\(C\)</span> (Capacitance), <span class="math notranslate nohighlight">\(E_l\)</span> (Resting potential), and <span class="math notranslate nohighlight">\(g_l\)</span> leak conductance, are parameters of the neuron. The state variable <span class="math notranslate nohighlight">\(V\)</span> represents the voltage, and the variable <span class="math notranslate nohighlight">\(I\)</span> is the input, which is taken as a current.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Define the constants and equations for the neuron model</span>

<span class="c1"># Neuron parameters</span>
<span class="n">C_Ax</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">nF</span> <span class="c1"># Capacitance </span>
<span class="n">g_l</span> <span class="o">=</span>  <span class="mf">5.0</span> <span class="o">*</span> <span class="n">nS</span> <span class="c1"># leak conductance</span>

<span class="n">E_l</span> <span class="o">=</span> <span class="o">-</span><span class="mf">60.0</span> <span class="o">*</span> <span class="n">mV</span> <span class="c1"># Resting potential</span>
<span class="n">V_t</span> <span class="o">=</span> <span class="o">-</span><span class="mf">55.0</span> <span class="o">*</span> <span class="n">mV</span> <span class="c1"># Threshold</span>
<span class="n">V_r</span> <span class="o">=</span> <span class="o">-</span><span class="mf">60.0</span> <span class="o">*</span> <span class="n">mV</span> <span class="c1"># Reset</span>

<span class="n">tref</span><span class="o">=</span><span class="mi">0</span><span class="o">*</span><span class="n">ms</span> <span class="c1"># refractory period</span>

<span class="n">eqs_if</span> <span class="o">=</span> <span class="n">Equations</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;</span>
<span class="s1">    dV/dt = (g_l * (E_l - V) + I_ext + I_syn) / C_Ax : volt (unless refractory)</span>
<span class="s1">    I_ext : amp</span>
<span class="s1">    I_syn : amp</span>
<span class="s1">    &#39;&#39;&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="simulating-if-neurons">
<h2>Simulating IF neurons<a class="headerlink" href="#simulating-if-neurons" title="Permalink to this headline">¶</a></h2>
<p>The integrate-and-fire neuron is just this capacitor equation with a spiking mechanism. In the most basic models, the spiking mechanism is simply a threshold. When the voltage exceeds this threshold, then the model outputs a “spike” and then the voltage is reset to a reset potential. The IF model does not actually simulate the spike dynamics. A refractory period is also often used, which forces the neuron to be inactive for a short period after a spike, but first we will start with the refractory period as 0.</p>
<p>Now, we are going to simulate the neuron model and examine the firing rate for a steady current injection. To do so, we will generate a group of IF neurons and inject each of them with different amounts of current. We will then count the number of output spikes to find a relationship between current and number of spikes.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Make a group of IF neurons</span>
<span class="n">N_s</span> <span class="o">=</span> <span class="mi">50</span>
<span class="n">G_post</span> <span class="o">=</span> <span class="n">NeuronGroup</span><span class="p">(</span><span class="n">N_s</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="n">eqs_if</span><span class="p">,</span> 
                     <span class="n">threshold</span><span class="o">=</span><span class="s1">&#39;V&gt;V_t&#39;</span><span class="p">,</span> 
                     <span class="n">reset</span><span class="o">=</span><span class="s1">&#39;V=V_r&#39;</span><span class="p">,</span> 
                     <span class="n">refractory</span><span class="o">=</span><span class="n">tref</span><span class="p">)</span>

<span class="c1"># Set initial conditions and inputs</span>
<span class="n">G_post</span><span class="o">.</span><span class="n">V</span> <span class="o">=</span> <span class="n">E_l</span> <span class="o">*</span> <span class="n">ones</span><span class="p">(</span><span class="n">N_s</span><span class="p">)</span>
<span class="c1"># Give each neuron a different amount of input current</span>
<span class="n">G_post</span><span class="o">.</span><span class="n">I_ext</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="n">N_s</span><span class="p">)</span> <span class="o">*</span> <span class="n">nA</span>

<span class="c1"># Monitor the simulation</span>
<span class="n">SpM_post</span> <span class="o">=</span> <span class="n">SpikeMonitor</span><span class="p">(</span><span class="n">G_post</span><span class="p">)</span>
<span class="n">StM_post</span> <span class="o">=</span> <span class="n">StateMonitor</span><span class="p">(</span><span class="n">G_post</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">record</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># Build the simulation network</span>
<span class="n">ifr_net</span> <span class="o">=</span> <span class="n">Network</span><span class="p">()</span>
<span class="n">ifr_net</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">G_post</span><span class="p">)</span>
<span class="n">ifr_net</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">SpM_post</span><span class="p">)</span>
<span class="n">ifr_net</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">StM_post</span><span class="p">)</span>

<span class="n">ifr_net</span><span class="o">.</span><span class="n">store</span><span class="p">(</span><span class="s1">&#39;init&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">run_time</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">second</span>
<span class="n">ifr_net</span><span class="o">.</span><span class="n">restore</span><span class="p">(</span><span class="s1">&#39;init&#39;</span><span class="p">)</span>
<span class="n">tst</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="n">ifr_net</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">run_time</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;elapsed&quot;</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">tst</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>WARNING    Removing unsupported flag &#39;-march=native&#39; from compiler flags. [brian2.codegen.cpp_prefs]
INFO       No numerical integration method specified for group &#39;neurongroup&#39;, using method &#39;exact&#39; (took 0.15s). [brian2.stateupdaters.base.method_choice]
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>elapsed 6.414305925369263
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">post_spikes</span> <span class="o">=</span> <span class="n">SpM_post</span><span class="o">.</span><span class="n">spike_trains</span><span class="p">()</span>
<span class="n">tot_spikes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N_s</span><span class="p">)</span>
<span class="n">ifr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N_s</span><span class="p">)</span>

<span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mf">3.5</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">post_spikes</span><span class="p">)):</span>
    <span class="n">plot</span><span class="p">(</span><span class="n">post_spikes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">second</span><span class="p">,</span> <span class="n">i</span> <span class="o">*</span> <span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">post_spikes</span><span class="p">[</span><span class="n">i</span><span class="p">])),</span> <span class="s1">&#39;|k&#39;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">post_spikes</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># estimate based on total spikes during simulation</span>
        <span class="n">tot_spikes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">post_spikes</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="c1"># estimate based on time between spikes</span>
        <span class="n">ifr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">post_spikes</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
    
<span class="n">ylim</span><span class="p">([</span><span class="mi">0</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">N_s</span><span class="o">-</span><span class="mf">0.5</span><span class="p">])</span>
<span class="n">xlim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">run_time</span><span class="o">/</span><span class="n">second</span><span class="p">])</span>
<span class="n">yticks</span><span class="p">([])</span>
<span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Time (s)&#39;</span><span class="p">)</span>
<span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Neuron&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Text(0, 0.5, &#39;Neuron&#39;)
</pre></div>
</div>
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>findfont: Font family [&#39;serif&#39;] not found. Falling back to DejaVu Sans.
findfont: Generic family &#39;serif&#39; not found because none of the following families were found: Computer Modern
</pre></div>
</div>
<img alt="../_images/spiking_basics_brian2_8_2.png" src="../_images/spiking_basics_brian2_8_2.png" />
</div>
</div>
<p>Lets take a look at the voltage dynamics of a particular neuron.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plot_idx</span> <span class="o">=</span> <span class="mi">15</span>

<span class="n">plot</span><span class="p">(</span><span class="n">StM_post</span><span class="o">.</span><span class="n">t</span><span class="p">,</span> <span class="n">StM_post</span><span class="o">.</span><span class="n">V</span><span class="p">[</span><span class="n">plot_idx</span><span class="p">])</span>
<span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Time (s)&#39;</span><span class="p">)</span>
<span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Voltage (V)&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Text(0, 0.5, &#39;Voltage (V)&#39;)
</pre></div>
</div>
<img alt="../_images/spiking_basics_brian2_10_1.png" src="../_images/spiking_basics_brian2_10_1.png" />
</div>
</div>
<p>This is a pretty simple dynamical system, and we can basically see how the simple RC circuit model is integrating the input current. Once the voltage reaches the threshold, then a spike is triggered and the voltage is instantly reset to the reset potential.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mf">3.5</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>

<span class="n">Id</span> <span class="o">=</span> <span class="n">G_post</span><span class="o">.</span><span class="n">I_ext</span>

<span class="n">plot</span><span class="p">(</span><span class="n">Id</span> <span class="o">/</span> <span class="n">nA</span><span class="p">,</span> <span class="n">tot_spikes</span> <span class="o">/</span> <span class="n">run_time</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Input Current (nA)&#39;</span><span class="p">)</span>
<span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Firing Rate (Hz)&#39;</span><span class="p">)</span>
<span class="n">xlim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">Id</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">nA</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(0.0, 0.2)
</pre></div>
</div>
<img alt="../_images/spiking_basics_brian2_12_1.png" src="../_images/spiking_basics_brian2_12_1.png" />
</div>
</div>
<p>We plotted the number of spikes during the 1-second simulation period. There seems to be a pretty simple pattern, but the result is a bit jagged. This is simply because there are some artifacts due to the way we calculated spikes per second. Basically the limited amount of simulation time leads to some rounding errors in our calculation.</p>
<p>As an alternative, lets estimate spikes per second based on the time between spikes for each neuron.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mf">3.5</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>

<span class="n">Id</span> <span class="o">=</span> <span class="n">G_post</span><span class="o">.</span><span class="n">I_ext</span>

<span class="n">plot</span><span class="p">(</span><span class="n">Id</span> <span class="o">/</span> <span class="n">nA</span><span class="p">,</span> <span class="n">ifr</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Input Current (nA)&#39;</span><span class="p">)</span>
<span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Firing Rate (Hz)&#39;</span><span class="p">)</span>
<span class="n">xlim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">Id</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">nA</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(0.0, 0.2)
</pre></div>
</div>
<img alt="../_images/spiking_basics_brian2_14_1.png" src="../_images/spiking_basics_brian2_14_1.png" />
</div>
</div>
<p>Now we can see clearly that the firing rate as a function of input current has some clear properties. There is a threshold below which there are no spikes.
When we have large amounts of current, then it seems that there is a linear relationship between current and firing rate.
We can solve some calculus problems to theoretically understand these properties.</p>
</div>
<div class="section" id="i-f-neuron-theory">
<h2>I&amp;F neuron theory<a class="headerlink" href="#i-f-neuron-theory" title="Permalink to this headline">¶</a></h2>
<p>We see from the simulations that the integrate-and-fire neuron model has a nearly linear input-output function – i.e. the number of spikes per second or the spiking rate appears to be linear with respect to input current once above the threshold. If we examine the model carefully, we can see that there is a basic calculus problem we can solve that will help us theoretically understand the behavior of the neuron.</p>
<div class="section" id="derivation-of-instantaneous-firing-rate-ifr">
<h3>Derivation of instantaneous-firing-rate (IFR)<a class="headerlink" href="#derivation-of-instantaneous-firing-rate-ifr" title="Permalink to this headline">¶</a></h3>
<p>To understand the relationship between firing rate and input current, we want to compute the time it takes to reach the threshold potential when starting at the reset potential when given a constant current input, <span class="math notranslate nohighlight">\(I_s\)</span>. Lets start with the differential equation for the IF neuron:</p>
<div class="math notranslate nohighlight">
\[
C \frac{dV}{dt} = g_l (E_l - V) + I_s
\]</div>
<p>This is a simple enough differential equation that we can actually solve it.</p>
<p>First, separate the Voltage and Time terms:</p>
<div class="math notranslate nohighlight">
\[
C\frac{dV}{g_l (E_l - V) + I_s} = dt
\]</div>
<p>Integrate both sides:</p>
<div class="math notranslate nohighlight">
\[
\int C\frac{dV}{g_l (E_l - V) + I_s} = \int dt
\]</div>
<div class="math notranslate nohighlight">
\[
- \frac{C}{g_l} \log (g_l (E_l - V) + I_s) = t + K
\]</div>
<p>Solve for V:</p>
<div class="math notranslate nohighlight">
\[
g_l (E_l - V) + I_s = K e^{-\frac{g_l}{C} t}
\]</div>
<div class="math notranslate nohighlight">
\[
V = I_s/g_l + E_l - K e^{-\frac{g_l}{C} t}
\]</div>
<p>(Note that above we have the constant <span class="math notranslate nohighlight">\(K\)</span> absorb the exponential function and the division by g_l.)</p>
<p>We want to solve for the time it takes to reach threshold starting from the reset potential. Therefore, we will set an initial condition where <span class="math notranslate nohighlight">\(V(t=0) = V_r\)</span>. We solve for the constant K based on this initial condition.</p>
<div class="math notranslate nohighlight">
\[
V_r = I_s/g_l + E_l - K
\]</div>
<div class="math notranslate nohighlight">
\[
K = g_l(E_l-V_r)+I_s
\]</div>
<p>With this initial condition giving us the integration constant, we can next solve the equation for the time <span class="math notranslate nohighlight">\(T_{spike}\)</span> at which the voltage exceeds the threshold <span class="math notranslate nohighlight">\(V(t=T_{spike}) = V_t\)</span>.</p>
<div class="math notranslate nohighlight">
\[
V_t = I_s/g_l + E_l - K e^{-\frac{g_l}{C} T_{spike}}
\]</div>
<div class="math notranslate nohighlight">
\[
\log \Big( \frac{g_l (E_l - V_t) + I_s}{g_l (E_l - V_r) + I_s} \Big) = \log e^{-\frac{g_l}{C} T_{spike}}
\]</div>
<p>Giving:</p>
<div class="math notranslate nohighlight">
\[
T_{spike} = \frac{C}{g_l} \log \Big( \frac{I_s + g_l (E_l - V_r)}{I_s + g_l (E_l - V_t)} \Big)
\]</div>
<p>The <em>instantaneous-firing-rate</em> (<span class="math notranslate nohighlight">\(IFR\)</span>) is the inverse of <span class="math notranslate nohighlight">\(T_{spike}\)</span>:</p>
<div class="math notranslate nohighlight">
\[
IFR = 1 / T_{spike}
\]</div>
</div>
<div class="section" id="linear-approximation-to-ifr">
<h3>Linear approximation to IFR<a class="headerlink" href="#linear-approximation-to-ifr" title="Permalink to this headline">¶</a></h3>
<p>Nice! We now have an equation for the spiking rate given a constant input current. What a fun little calculus problem.</p>
<p>We see that the plot appears to converge to a straight line, but our equation for the <span class="math notranslate nohighlight">\(IFR\)</span> looks far from linear. How can we mathematically derive this line?</p>
<p>If we want a linear apporximation of firing rate, then we need a linear formulation:</p>
<div class="math notranslate nohighlight">
\[
\tilde{IFR} = m I_s + b
\]</div>
<p>To find the line, then note that the linear relationship we see in the plots only becomes linear for large values of the input current. With this, we can use a limit to compute the slope of the line:</p>
<div class="math notranslate nohighlight">
\[
m = \lim_{I_s \to \infty} \frac{d}{dI_s} IFR
\]</div>
<p>I’ll leave it to you to work out the calculus, this one gets pretty gnarly… Alternatively, we can just use <a class="reference external" href="https://www.wolframalpha.com/input/?i2d=true&amp;i=Limit%5BD%5BDivide%5B1%2CDivide%5BC%2Cg%5Dlog%5C%2840%29Divide%5B%5C%2840%29I%2Bg*%5C%2840%29E_l-V_r%5C%2841%29%5C%2841%29%2C%5C%2840%29I%2Bg*%5C%2840%29E_l-V_t%5C%2841%29%5C%2841%29%5D%5C%2841%29%5D%2CI%5D%2CI-%3Einfinity%5D">wolframalpha</a>!</p>
<p>This gives us a pretty simple formula for the slope of the line:</p>
<div class="math notranslate nohighlight">
\[
m = \frac{1.0}{C (V_{t} - V_{r})}
\]</div>
<p>With this as the slope, we can then solve for <span class="math notranslate nohighlight">\(b\)</span> based on:</p>
<div class="math notranslate nohighlight">
\[
b = \lim_{I_s \to \infty} IFR - m I_s 
\]</div>
<p>Yes, <a class="reference external" href="https://www.wolframalpha.com/input/?i2d=true&amp;i=Limit%5BDivide%5B1%2C%5C%2840%29Divide%5BC%2Cg%5D%5C%2841%29+*log%5C%2840%29Divide%5B%5C%2840%29I%2Bg*%5C%2840%29P-R%5C%2841%29%5C%2841%29%2C%5C%2840%29I%2Bg*%5C%2840%29P-T%5C%2841%29%5C%2841%29%5D%5C%2841%29%5D-Divide%5BI%2CC*%5C%2840%29T-R%5C%2841%29%5D%2CI-%3Einfinity%5D">wolframalpha</a> time!
Leaving us with an equation for the offset:</p>
<div class="math notranslate nohighlight">
\[
b = \frac{-g_l ((V_{t} - E_l) + (V_{r} - E_l))}{2C_{Ax} (V_{t} - V_{r})}
\]</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">m_ifr</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">C_Ax</span> <span class="o">*</span> <span class="p">(</span><span class="n">V_t</span> <span class="o">-</span> <span class="n">V_r</span><span class="p">))</span>
<span class="n">b</span> <span class="o">=</span> <span class="o">-</span><span class="n">g_l</span> <span class="o">*</span> <span class="p">(</span><span class="n">V_t</span> <span class="o">+</span> <span class="n">V_r</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">E_l</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">C_Ax</span> <span class="o">*</span> <span class="p">(</span><span class="n">V_t</span> <span class="o">-</span> <span class="n">V_r</span><span class="p">))</span>


<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;slope:&quot;</span><span class="p">,</span> <span class="n">m_ifr</span><span class="p">,</span> 
      <span class="s2">&quot;; offset:&quot;</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>slope: 1.e+11 s^-1 A^-1 ; offset: -1.25 Hz
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="spike-threshold">
<h3>Spike threshold<a class="headerlink" href="#spike-threshold" title="Permalink to this headline">¶</a></h3>
<p>There is one other useful property that we can derive from the mathematics of the IF neuron, the minimum threshold for spiking.</p>
<p>If we look at the formula for <span class="math notranslate nohighlight">\(T_{spike}\)</span>, we can see that if the input current <span class="math notranslate nohighlight">\(I_s\)</span> is small, then the term inside of the logarithm is negative. When this is the case, then there will be no output spikes. As soon as the current makes the term inside the logarithm positive, then the neuron will produce spikes. So it is very simple to find the minimum current <span class="math notranslate nohighlight">\(I_{min}\)</span> needed to produce any output spikes:</p>
<div class="math notranslate nohighlight">
\[
I_{min} + g_l (E_l - V_t) &gt; 0
\]</div>
<div class="math notranslate nohighlight">
\[
I_{min} &gt; g_l (V_t - E_l)
\]</div>
<p>This makes intuitive sense, there must be enough current to reach the threshold potential and overcome the leakage.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">I_min</span> <span class="o">=</span> <span class="n">g_l</span> <span class="o">*</span> <span class="p">(</span><span class="n">V_t</span> <span class="o">-</span> <span class="n">E_l</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">I_min</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>25. pA
</pre></div>
</div>
</div>
</div>
<p>Finally, lets see how the theory fits with the simulation.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mf">3.5</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>

<span class="n">Id</span> <span class="o">=</span> <span class="n">G_post</span><span class="o">.</span><span class="n">I_ext</span>

<span class="n">plot</span><span class="p">(</span><span class="n">Id</span> <span class="o">/</span> <span class="n">nA</span><span class="p">,</span> <span class="n">ifr</span> <span class="o">/</span> <span class="n">second</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<span class="n">t_spike</span> <span class="o">=</span> <span class="n">C_Ax</span> <span class="o">/</span> <span class="n">g_l</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">((</span><span class="n">Id</span><span class="o">+</span><span class="n">g_l</span><span class="o">*</span><span class="p">(</span><span class="n">E_l</span> <span class="o">-</span> <span class="n">V_r</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="n">Id</span><span class="o">+</span><span class="n">g_l</span><span class="o">*</span><span class="p">(</span><span class="n">E_l</span> <span class="o">-</span> <span class="n">V_t</span><span class="p">)))</span>
<span class="n">fr</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">t_spike</span>
<span class="n">fr</span><span class="p">[</span><span class="n">isnan</span><span class="p">(</span><span class="n">fr</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>

<span class="n">plot</span><span class="p">(</span><span class="n">Id</span><span class="o">/</span><span class="n">nA</span><span class="p">,</span> <span class="n">fr</span> <span class="o">/</span> <span class="n">second</span><span class="p">,</span> <span class="s1">&#39;--r&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>


<span class="c1">#Ish = np.linspace(0, G_post.I_ext[-1]/nA, 500) * nA</span>

<span class="n">plot</span><span class="p">(</span><span class="n">Id</span><span class="o">/</span><span class="n">nA</span><span class="p">,</span> <span class="p">(</span><span class="n">m_ifr</span> <span class="o">*</span> <span class="n">Id</span> <span class="o">+</span> <span class="n">b</span><span class="p">),</span> <span class="s1">&#39;:c&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<span class="n">plot</span><span class="p">([</span><span class="n">I_min</span><span class="p">,</span> <span class="n">I_min</span><span class="p">]</span><span class="o">/</span><span class="n">nA</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">15</span><span class="p">],</span> <span class="s1">&#39;:m&#39;</span><span class="p">)</span>


<span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Input Current (nA)&#39;</span><span class="p">)</span>
<span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Firing Rate (Hz)&#39;</span><span class="p">)</span>
<span class="n">xlim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">Id</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">nA</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>WARNING    /opt/homebrew/Caskroom/miniforge/base/lib/python3.9/site-packages/brian2/units/fundamentalunits.py:208: RuntimeWarning: divide by zero encountered in log
  return func(np.array(x, copy=False), *args, **kwds)
 [py.warnings]
WARNING    /opt/homebrew/Caskroom/miniforge/base/lib/python3.9/site-packages/brian2/units/fundamentalunits.py:208: RuntimeWarning: invalid value encountered in log
  return func(np.array(x, copy=False), *args, **kwds)
 [py.warnings]
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(0.0, 0.2)
</pre></div>
</div>
<img alt="../_images/spiking_basics_brian2_22_2.png" src="../_images/spiking_basics_brian2_22_2.png" />
</div>
</div>
</div>
</div>
<div class="section" id="if-neuron-with-refractory-period">
<h2>IF neuron with refractory period<a class="headerlink" href="#if-neuron-with-refractory-period" title="Permalink to this headline">¶</a></h2>
<p>One final thing we can examine is the refractory period. The refractory period has long been observed in neuroscience, where after spiking the neuron is unresponsive to inputs. This is typically due to the dynamics of the channels during a biophysical spike. When using integrate-and-fire neurons, the refractory period is simply a period where the dynamics of the neuron are clamped to the reset potential. Its very simple to add a refractory period to a neuron in Brian2.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">tref</span> <span class="o">=</span> <span class="mi">50</span><span class="o">*</span><span class="n">ms</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Make a group of IF neurons</span>
<span class="n">N_s</span> <span class="o">=</span> <span class="mi">50</span>
<span class="n">G_post</span> <span class="o">=</span> <span class="n">NeuronGroup</span><span class="p">(</span><span class="n">N_s</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="n">eqs_if</span><span class="p">,</span> 
                     <span class="n">threshold</span><span class="o">=</span><span class="s1">&#39;V&gt;V_t&#39;</span><span class="p">,</span> 
                     <span class="n">reset</span><span class="o">=</span><span class="s1">&#39;V=V_r&#39;</span><span class="p">,</span> 
                     <span class="n">refractory</span><span class="o">=</span><span class="n">tref</span><span class="p">)</span>

<span class="c1"># Set initial conditions and inputs</span>
<span class="n">G_post</span><span class="o">.</span><span class="n">V</span> <span class="o">=</span> <span class="n">E_l</span> <span class="o">*</span> <span class="n">ones</span><span class="p">(</span><span class="n">N_s</span><span class="p">)</span>
<span class="n">G_post</span><span class="o">.</span><span class="n">I_ext</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">N_s</span><span class="p">)</span> <span class="o">*</span> <span class="n">nA</span>

<span class="c1"># Monitor the simulation</span>
<span class="n">SpM_post</span> <span class="o">=</span> <span class="n">SpikeMonitor</span><span class="p">(</span><span class="n">G_post</span><span class="p">)</span>
<span class="n">StM_post</span> <span class="o">=</span> <span class="n">StateMonitor</span><span class="p">(</span><span class="n">G_post</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">record</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># Build the simulation network</span>
<span class="n">ifr_net</span> <span class="o">=</span> <span class="n">Network</span><span class="p">()</span>
<span class="n">ifr_net</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">G_post</span><span class="p">)</span>
<span class="n">ifr_net</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">SpM_post</span><span class="p">)</span>
<span class="n">ifr_net</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">StM_post</span><span class="p">)</span>

<span class="n">ifr_net</span><span class="o">.</span><span class="n">store</span><span class="p">(</span><span class="s1">&#39;init&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">run_time</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">second</span>
<span class="n">ifr_net</span><span class="o">.</span><span class="n">restore</span><span class="p">(</span><span class="s1">&#39;init&#39;</span><span class="p">)</span>
<span class="n">tst</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="n">ifr_net</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">run_time</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;elapsed&quot;</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">tst</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>INFO       No numerical integration method specified for group &#39;neurongroup_1&#39;, using method &#39;exact&#39; (took 0.05s). [brian2.stateupdaters.base.method_choice]
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>elapsed 5.269563913345337
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">post_spikes</span> <span class="o">=</span> <span class="n">SpM_post</span><span class="o">.</span><span class="n">spike_trains</span><span class="p">()</span>
<span class="n">tot_spikes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N_s</span><span class="p">)</span>
<span class="n">ifr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N_s</span><span class="p">)</span>

<span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mf">3.5</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">post_spikes</span><span class="p">)):</span>
    <span class="n">plot</span><span class="p">(</span><span class="n">post_spikes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">second</span><span class="p">,</span> <span class="n">i</span> <span class="o">*</span> <span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">post_spikes</span><span class="p">[</span><span class="n">i</span><span class="p">])),</span> <span class="s1">&#39;|k&#39;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">post_spikes</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># estimate based on total spikes during simulation</span>
        <span class="n">tot_spikes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">post_spikes</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="c1"># estimate based on time between spikes</span>
        <span class="n">ifr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">post_spikes</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
    
<span class="n">ylim</span><span class="p">([</span><span class="mi">0</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">N_s</span><span class="o">-</span><span class="mf">0.5</span><span class="p">])</span>
<span class="n">xlim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">run_time</span><span class="o">/</span><span class="n">second</span><span class="p">])</span>
<span class="n">yticks</span><span class="p">([])</span>
<span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Time (s)&#39;</span><span class="p">)</span>
<span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Neuron&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Text(0, 0.5, &#39;Neuron&#39;)
</pre></div>
</div>
<img alt="../_images/spiking_basics_brian2_27_1.png" src="../_images/spiking_basics_brian2_27_1.png" />
</div>
</div>
<div class="section" id="ifr-theory-with-refractory-period">
<h3>IFR theory with refractory period<a class="headerlink" href="#ifr-theory-with-refractory-period" title="Permalink to this headline">¶</a></h3>
<p>Including the refractory period <span class="math notranslate nohighlight">\(\tau_{ref}\)</span> is quite simple in our theoretical analysis. We just add the refractory period to the formula for <span class="math notranslate nohighlight">\(T_{spike}\)</span>:</p>
<div class="math notranslate nohighlight">
\[
T_{spike} = \frac{C}{g_l} \log \Big( \frac{I_s + g_l (E_l - V_r)}{I_s + g_l (E_l - V_t)} \Big) + \tau_{ref}
\]</div>
<p>However, it should be obvious that this new formula will not continue to converge to a straight line. Rather, the refractory period causes the spiking rate to saturate to a maximum. This maximum spike rate is simply:</p>
<div class="math notranslate nohighlight">
\[
IFR_{max} = 1/\tau_{ref}
\]</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ifr_max</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">tref</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mf">3.5</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>

<span class="n">Id</span> <span class="o">=</span> <span class="n">G_post</span><span class="o">.</span><span class="n">I_ext</span>

<span class="n">plot</span><span class="p">(</span><span class="n">Id</span> <span class="o">/</span> <span class="n">nA</span><span class="p">,</span> <span class="n">ifr</span> <span class="o">/</span> <span class="n">second</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<span class="n">t_spike</span> <span class="o">=</span> <span class="n">C_Ax</span> <span class="o">/</span> <span class="n">g_l</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">((</span><span class="n">Id</span><span class="o">+</span><span class="n">g_l</span><span class="o">*</span><span class="p">(</span><span class="n">E_l</span> <span class="o">-</span> <span class="n">V_r</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="n">Id</span><span class="o">+</span><span class="n">g_l</span><span class="o">*</span><span class="p">(</span><span class="n">E_l</span> <span class="o">-</span> <span class="n">V_t</span><span class="p">)))</span> <span class="o">+</span> <span class="n">tref</span>
<span class="n">fr</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">t_spike</span>
<span class="n">fr</span><span class="p">[</span><span class="n">isnan</span><span class="p">(</span><span class="n">fr</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>

<span class="n">plot</span><span class="p">(</span><span class="n">Id</span><span class="o">/</span><span class="n">nA</span><span class="p">,</span> <span class="n">fr</span> <span class="o">/</span> <span class="n">second</span><span class="p">,</span> <span class="s1">&#39;--r&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>


<span class="c1">#Ish = np.linspace(0, G_post.I_ext[-1]/nA, 500) * nA</span>

<span class="n">plot</span><span class="p">(</span><span class="n">Id</span><span class="o">/</span><span class="n">nA</span><span class="p">,</span> <span class="p">(</span><span class="n">m_ifr</span> <span class="o">*</span> <span class="n">Id</span> <span class="o">+</span> <span class="n">b</span><span class="p">),</span> <span class="s1">&#39;:c&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<span class="n">plot</span><span class="p">([</span><span class="n">I_min</span><span class="p">,</span> <span class="n">I_min</span><span class="p">]</span><span class="o">/</span><span class="n">nA</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">15</span><span class="p">],</span> <span class="s1">&#39;:m&#39;</span><span class="p">)</span>

<span class="n">plot</span><span class="p">([</span><span class="n">Id</span><span class="p">[:]</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">Id</span><span class="p">[:]</span><span class="o">.</span><span class="n">max</span><span class="p">()]</span><span class="o">/</span><span class="n">nA</span><span class="p">,</span> <span class="p">[</span><span class="n">ifr_max</span><span class="p">,</span> <span class="n">ifr_max</span><span class="p">],</span> <span class="s1">&#39;:b&#39;</span><span class="p">)</span>


<span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Input Current (nA)&#39;</span><span class="p">)</span>
<span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Firing Rate (Hz)&#39;</span><span class="p">)</span>
<span class="n">xlim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">Id</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">nA</span><span class="p">])</span>
<span class="n">ylim</span><span class="p">([</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">30</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>WARNING    /opt/homebrew/Caskroom/miniforge/base/lib/python3.9/site-packages/brian2/units/fundamentalunits.py:208: RuntimeWarning: divide by zero encountered in log
  return func(np.array(x, copy=False), *args, **kwds)
 [py.warnings]
WARNING    /opt/homebrew/Caskroom/miniforge/base/lib/python3.9/site-packages/brian2/units/fundamentalunits.py:208: RuntimeWarning: invalid value encountered in log
  return func(np.array(x, copy=False), *args, **kwds)
 [py.warnings]
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(-5.0, 30.0)
</pre></div>
</div>
<img alt="../_images/spiking_basics_brian2_30_2.png" src="../_images/spiking_basics_brian2_30_2.png" />
</div>
</div>
</div>
</div>
<div class="section" id="conclusions">
<h2>Conclusions<a class="headerlink" href="#conclusions" title="Permalink to this headline">¶</a></h2>
<p>We covered here how we can formalize the integrate-and-fire neuron into a reliable mathematical model where information is represented by the firing rate of the spikes. We were able to derive an equation, the <span class="math notranslate nohighlight">\(IFR\)</span>, that computes the firing rate based on the input current and the parameters of the neuron model. We also showed that this function is rectified linear when there is no refractory period, and that it is saturating when there is a refractory period, and we analyzed useful approximations to have a mathematical grasp on the behavior of IF neurons.</p>
<p>The analysis done here required the assumption that the inputs to the neurons are static. But is this useful then when the inputs are changing as data comes in from sensors? This is a type of approximation that is often used in control theory, where we can define a regime in which the equations are valid based on dynamics that are occuring at different time-scales. In this case, we are assuming that the input changes slowly compared to the spiking output. Effectively, for the <span class="math notranslate nohighlight">\(IFR\)</span> equations to be useful, we assume that the input is band-limited and lower frequency than the typical spiking frequency. We can be sure of such situations based on the timeconstants of the neurons and synapses.</p>
<p>But, what if the inputs are fast compared to the neurons? Well, in this case we must rely on a different theory – this regime is outside the scope of the <span class="math notranslate nohighlight">\(IFR\)</span> theory.</p>
<p>To fully connect the dynamics of integrate-and-fire neurons to connectionist theory, we must also exmaine how spikes interact with synapses and how these are integrated to perform computations like the dot-product. In the next section, we will explore exactly how IF models can be used to compute the dot-product and fully tie-in basic spiking models into connectionist theory.</p>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./Tutorials"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        
            <!-- Previous / next buttons -->
<div class='prev-next-area'> 
    <a class='left-prev' id="prev-link" href="computational_neuroscience.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title">Computational Neuroscience</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="connecting_if_neurons.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Connecting IFR theory to connectionism</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
        
        </div>
    </div>
    <footer class="footer">
  <p>
    
      By Dr. E. Paxon Frady<br/>
    
        &copy; Copyright 2021.<br/>
  </p>
</footer>
</main>


      </div>
    </div>
  
  <script src="../_static/js/index.be7d3bbb2ef33a8344ce.js"></script>

  </body>
</html>